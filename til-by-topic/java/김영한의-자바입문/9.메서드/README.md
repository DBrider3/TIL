# 9. 메서드

# 메서드 사용

자바에서는 함수를 메서드(Method)라 한다.

메서드도 함수의 한 종류라고 생각하면 된다. 

메서드는 크게 `메서드 선언`과 `메서드 본문`으로 나눌 수 있다.

### 메서드 선언 (Method Declaration)

`public static int add(int a, int b)`

- public static
    - public: 접근제어
    - static: 객체를 생성하지 않고 호출할 수 있는 정적 메서드라는 뜻이다.
    - 자세한건 뒤에서 다루자. 지금은 단순하게 메서드를 만들 때 둘을 사용해야 한다고 생각하기

### 메서드 호출과 용어정리

**인수(Argument)**

넘기는 값을 아규먼트, 인수 또는 인자라고 함

**매개변수(Parameter)**

메서드를 정의할 때 선언한 변수인 `String str`, `int age`를 매개변수, 파라미터라 한다.

그래서 메서드를 호출할 때 인수를 넘기면, 그 인수가 매개변수에 대입된다.

**용어정리**

- **인수**라는 용어는 '인’과 '수’의 합성어로, '들어가는 수’라는 의미를 가진다. 즉, 메서드 내부로 들어가는 값을 의미한다. 인자도 같은 의미이다.
- **매개변수, parameter**는 '매개’와 '변수’의 합성어로, '중간에서 전달하는 변수’라는 의미를 가진다. 즉, 메서드 호출부와 메서드 내부 사이에서 값을 전달하는 역할을 하는 변수라는 뜻이다.

# 메서드 호출과 값 전달1

**지금부터 자바에서 아주 중요한 대원칙 하나를 이야기 한다.!!!!!**

### 자바는 항상 변수의 값을 복사해서 대입한다.

이 대원칙은 반드시 이해해야 한다. 그러면 아무리 복잡한 상황에도 코드를 단순하게 이해할 수 있다.

### 메서드 호출과 값 복사

```java
package method;

public class MethodValue1 {
     public static void main(String[] args) {
					int num1 = 5;
					System.out.println("1. changeNumber 호출 전, num1: " + num1); 
					changeNumber(num1);
					System.out.println("4. changeNumber 호출 후, num1: " + num1);
			}
			public static void changeNumber(int num2) { 
					System.out.println("2. changeNumber 변경 전, num2: " + num2); 
					num2 = num2 * 2;
					System.out.println("3. changeNumber 변경 후, num2: " + num2);
			} 
}
```

실행 결과

```java
1. changeNumber 호출 전, num1: 5
2. changeNumber 변경 전, num2: 5
3. changeNumber 변경 후, num2: 10
4. changeNumber 호출 후, num1: 5
```

대원칙을 따라간다면 문제를 정확히 풀 수 있다.

**자바는 항상 변수의 값을 복사해서 대입한다.**

메서드의 파라미터에 값을 복사해서 전달 준다. 그래서 `num2`의 값을 바꾸더라도 `num1`에는 영향을 주지 않는다.

## 메서드 호출과 값 반환받기

`return`으로 값을 반환받아 대입연산자를 통해 넣어주면 된다.

# 메서드와 형변환

메서드를 호출하는데 인자와 매개변수의 타입이 맞지 않다면?

- 인자에 명시적 형변환을 해준다.
- 작은 자료형에서 큰 자료형으로 대입할때는 자동 형변환이 그대로 적용된다.

# 메서드 오버로딩

### 규칙

이름이 같고 매개변수가 다른 메서드를 여러개 정의하는 것을 메서드 오버로딩(Overloading)이라 한다.

오버로딩은 번역하면 과적인데, 과하게 물건을 담았다는 뜻이다. 따라서 같은 이름의 메서드를 여러개 정의했다고 이해하면 된다.

메서드의 이름이 같아도 매개변수의 타입 및 순서가 다르면 오버로딩을 할 수 있다. 참고로 반환 타입은 인정하지 않는다.

### 용어: 메서드 시그니처(method signature)

`메서드 시그니처 = 메서드 이름 + 매개변수 타입(순서)`

메서드 이름이 같아도 메서드 시그니처가 다르면 다른 메서드로 간주한다. 반환 타입은 시그니처에 포함되지 않는다. 

# 정리

### 변수명 vs 메서드명

변수 이름은 일반적으로 명사를 사용한다. 한편 메서드는 무언가 동작하는데 사용하기 때문에 일반적으로 동사로 시작

이런 차이점 외에는 변수 이름과 메서드 이름에 대한 규칙은 둘다 같다.

- 변수명 예): `customerName` , `totalSum` , `employeeCount` , `isAvailable`
- 메서드명 예): `printReport()` , `calculateSum()` , `addCustomer()`, `getEmployeeCount()` , `setEmployeeName()`

### 메서드 사용의 장점

- **코드 재사용**: 메서드는 특정 기능을 캡슐화하므로, 필요할 때마다 그 기능을 다시 작성할 필요 없이 해당 메서드를 호출함으로써 코드를 재사용할 수 있다.
- **코드의 가독성**: 이름이 부여된 메서드는 코드가 수행하는 작업을 명확하게 나타내므로, 코드를 읽는 사람에게 추가적인 문맥을 제공한다.
- **모듈성**: 큰 프로그램을 작은, 관리 가능한 부분으로 나눌 수 있다. 이는 코드의 가독성을 향상시키고 디버깅을 쉽게 만든다.
- **코드 유지 관리**: 메서드를 사용하면, 코드의 특정 부분에서 문제가 발생하거나 업데이트가 필요한 경우 해당 메서드만 수정하면 된다. 이렇게 하면 전체 코드 베이스에 영향을 주지 않고 변경 사항을 적용할 수 있다.
- **재사용성과 확장성**: 잘 설계된 메서드는 다른 프로그램이나 프로젝트에서도 재사용할 수 있으며, 새로운 기능을 추가하거나 기존 기능을 확장하는 데 유용하다.
- **추상화**: 메서드를 사용하는 곳에서는 메서드의 구현을 몰라도 된다. 프로그램의 다른 부분에서는 복잡한 내부 작업에 대해 알 필요 없이 메서드를 사용할 수 있다.
- **테스트와 디버깅 용이성**: 개별 메서드는 독립적으로 테스트하고 디버그할 수 있다. 이는 코드의 문제를 신속하게 찾고 수정하는 데 도움이 된다.

따라서, 메서드는 효율적이고 유지 보수가 가능한 코드를 작성하는 데 매우 중요한 도구이다.